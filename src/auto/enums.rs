// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files.git)
// DO NOT EDIT

use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use std::fmt;

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitAuthenticationScheme")]
pub enum AuthenticationScheme {
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_DEFAULT")]
    Default,
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_HTTP_BASIC")]
    HttpBasic,
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_HTTP_DIGEST")]
    HttpDigest,
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_HTML_FORM")]
    HtmlForm,
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_NTLM")]
    Ntlm,
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_NEGOTIATE")]
    Negotiate,
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE_REQUESTED")]
    ClientCertificateRequested,
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_SERVER_TRUST_EVALUATION_REQUESTED")]
    ServerTrustEvaluationRequested,
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_UNKNOWN")]
    Unknown,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
impl fmt::Display for AuthenticationScheme {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AuthenticationScheme::{}",
            match *self {
                AuthenticationScheme::Default => "Default",
                AuthenticationScheme::HttpBasic => "HttpBasic",
                AuthenticationScheme::HttpDigest => "HttpDigest",
                AuthenticationScheme::HtmlForm => "HtmlForm",
                AuthenticationScheme::Ntlm => "Ntlm",
                AuthenticationScheme::Negotiate => "Negotiate",
                AuthenticationScheme::ClientCertificateRequested => "ClientCertificateRequested",
                AuthenticationScheme::ServerTrustEvaluationRequested =>
                    "ServerTrustEvaluationRequested",
                AuthenticationScheme::Unknown => "Unknown",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
#[doc(hidden)]
impl ToGlib for AuthenticationScheme {
    type GlibType = ffi::WebKitAuthenticationScheme;

    fn to_glib(&self) -> ffi::WebKitAuthenticationScheme {
        match *self {
            AuthenticationScheme::Default => ffi::WEBKIT_AUTHENTICATION_SCHEME_DEFAULT,
            AuthenticationScheme::HttpBasic => ffi::WEBKIT_AUTHENTICATION_SCHEME_HTTP_BASIC,
            AuthenticationScheme::HttpDigest => ffi::WEBKIT_AUTHENTICATION_SCHEME_HTTP_DIGEST,
            AuthenticationScheme::HtmlForm => ffi::WEBKIT_AUTHENTICATION_SCHEME_HTML_FORM,
            AuthenticationScheme::Ntlm => ffi::WEBKIT_AUTHENTICATION_SCHEME_NTLM,
            AuthenticationScheme::Negotiate => ffi::WEBKIT_AUTHENTICATION_SCHEME_NEGOTIATE,
            AuthenticationScheme::ClientCertificateRequested => {
                ffi::WEBKIT_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE_REQUESTED
            }
            AuthenticationScheme::ServerTrustEvaluationRequested => {
                ffi::WEBKIT_AUTHENTICATION_SCHEME_SERVER_TRUST_EVALUATION_REQUESTED
            }
            AuthenticationScheme::Unknown => ffi::WEBKIT_AUTHENTICATION_SCHEME_UNKNOWN,
            AuthenticationScheme::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitAuthenticationScheme> for AuthenticationScheme {
    unsafe fn from_glib(value: ffi::WebKitAuthenticationScheme) -> Self {
        skip_assert_initialized!();
        match value {
            1 => AuthenticationScheme::Default,
            2 => AuthenticationScheme::HttpBasic,
            3 => AuthenticationScheme::HttpDigest,
            4 => AuthenticationScheme::HtmlForm,
            5 => AuthenticationScheme::Ntlm,
            6 => AuthenticationScheme::Negotiate,
            7 => AuthenticationScheme::ClientCertificateRequested,
            8 => AuthenticationScheme::ServerTrustEvaluationRequested,
            100 => AuthenticationScheme::Unknown,
            value => AuthenticationScheme::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
impl StaticType for AuthenticationScheme {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_authentication_scheme_get_type()) }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
impl<'a> FromValueOptional<'a> for AuthenticationScheme {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
impl<'a> FromValue<'a> for AuthenticationScheme {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
impl SetValue for AuthenticationScheme {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitAutomationBrowsingContextPresentation")]
pub enum AutomationBrowsingContextPresentation {
    #[doc(alias = "WEBKIT_AUTOMATION_BROWSING_CONTEXT_PRESENTATION_WINDOW")]
    Window,
    #[doc(alias = "WEBKIT_AUTOMATION_BROWSING_CONTEXT_PRESENTATION_TAB")]
    Tab,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl fmt::Display for AutomationBrowsingContextPresentation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AutomationBrowsingContextPresentation::{}",
            match *self {
                AutomationBrowsingContextPresentation::Window => "Window",
                AutomationBrowsingContextPresentation::Tab => "Tab",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
#[doc(hidden)]
impl ToGlib for AutomationBrowsingContextPresentation {
    type GlibType = ffi::WebKitAutomationBrowsingContextPresentation;

    fn to_glib(&self) -> ffi::WebKitAutomationBrowsingContextPresentation {
        match *self {
            AutomationBrowsingContextPresentation::Window => {
                ffi::WEBKIT_AUTOMATION_BROWSING_CONTEXT_PRESENTATION_WINDOW
            }
            AutomationBrowsingContextPresentation::Tab => {
                ffi::WEBKIT_AUTOMATION_BROWSING_CONTEXT_PRESENTATION_TAB
            }
            AutomationBrowsingContextPresentation::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitAutomationBrowsingContextPresentation>
    for AutomationBrowsingContextPresentation
{
    unsafe fn from_glib(value: ffi::WebKitAutomationBrowsingContextPresentation) -> Self {
        skip_assert_initialized!();
        match value {
            0 => AutomationBrowsingContextPresentation::Window,
            1 => AutomationBrowsingContextPresentation::Tab,
            value => AutomationBrowsingContextPresentation::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl StaticType for AutomationBrowsingContextPresentation {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_automation_browsing_context_presentation_get_type()) }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl<'a> FromValueOptional<'a> for AutomationBrowsingContextPresentation {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl<'a> FromValue<'a> for AutomationBrowsingContextPresentation {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl SetValue for AutomationBrowsingContextPresentation {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitAutoplayPolicy")]
pub enum AutoplayPolicy {
    #[doc(alias = "WEBKIT_AUTOPLAY_ALLOW")]
    Allow,
    #[doc(alias = "WEBKIT_AUTOPLAY_ALLOW_WITHOUT_SOUND")]
    AllowWithoutSound,
    #[doc(alias = "WEBKIT_AUTOPLAY_DENY")]
    Deny,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
impl fmt::Display for AutoplayPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AutoplayPolicy::{}",
            match *self {
                AutoplayPolicy::Allow => "Allow",
                AutoplayPolicy::AllowWithoutSound => "AllowWithoutSound",
                AutoplayPolicy::Deny => "Deny",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
#[doc(hidden)]
impl ToGlib for AutoplayPolicy {
    type GlibType = ffi::WebKitAutoplayPolicy;

    fn to_glib(&self) -> ffi::WebKitAutoplayPolicy {
        match *self {
            AutoplayPolicy::Allow => ffi::WEBKIT_AUTOPLAY_ALLOW,
            AutoplayPolicy::AllowWithoutSound => ffi::WEBKIT_AUTOPLAY_ALLOW_WITHOUT_SOUND,
            AutoplayPolicy::Deny => ffi::WEBKIT_AUTOPLAY_DENY,
            AutoplayPolicy::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitAutoplayPolicy> for AutoplayPolicy {
    unsafe fn from_glib(value: ffi::WebKitAutoplayPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => AutoplayPolicy::Allow,
            1 => AutoplayPolicy::AllowWithoutSound,
            2 => AutoplayPolicy::Deny,
            value => AutoplayPolicy::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
impl StaticType for AutoplayPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_autoplay_policy_get_type()) }
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
impl<'a> FromValueOptional<'a> for AutoplayPolicy {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
impl<'a> FromValue<'a> for AutoplayPolicy {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
impl SetValue for AutoplayPolicy {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitCacheModel")]
pub enum CacheModel {
    #[doc(alias = "WEBKIT_CACHE_MODEL_DOCUMENT_VIEWER")]
    DocumentViewer,
    #[doc(alias = "WEBKIT_CACHE_MODEL_WEB_BROWSER")]
    WebBrowser,
    #[doc(alias = "WEBKIT_CACHE_MODEL_DOCUMENT_BROWSER")]
    DocumentBrowser,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CacheModel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CacheModel::{}",
            match *self {
                CacheModel::DocumentViewer => "DocumentViewer",
                CacheModel::WebBrowser => "WebBrowser",
                CacheModel::DocumentBrowser => "DocumentBrowser",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CacheModel {
    type GlibType = ffi::WebKitCacheModel;

    fn to_glib(&self) -> ffi::WebKitCacheModel {
        match *self {
            CacheModel::DocumentViewer => ffi::WEBKIT_CACHE_MODEL_DOCUMENT_VIEWER,
            CacheModel::WebBrowser => ffi::WEBKIT_CACHE_MODEL_WEB_BROWSER,
            CacheModel::DocumentBrowser => ffi::WEBKIT_CACHE_MODEL_DOCUMENT_BROWSER,
            CacheModel::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitCacheModel> for CacheModel {
    unsafe fn from_glib(value: ffi::WebKitCacheModel) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CacheModel::DocumentViewer,
            1 => CacheModel::WebBrowser,
            2 => CacheModel::DocumentBrowser,
            value => CacheModel::__Unknown(value),
        }
    }
}

impl StaticType for CacheModel {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_cache_model_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CacheModel {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CacheModel {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CacheModel {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitContextMenuAction")]
pub enum ContextMenuAction {
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_NO_ACTION")]
    NoAction,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK")]
    OpenLink,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK_IN_NEW_WINDOW")]
    OpenLinkInNewWindow,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_LINK_TO_DISK")]
    DownloadLinkToDisk,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_COPY_LINK_TO_CLIPBOARD")]
    CopyLinkToClipboard,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OPEN_IMAGE_IN_NEW_WINDOW")]
    OpenImageInNewWindow,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_IMAGE_TO_DISK")]
    DownloadImageToDisk,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_COPY_IMAGE_TO_CLIPBOARD")]
    CopyImageToClipboard,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_COPY_IMAGE_URL_TO_CLIPBOARD")]
    CopyImageUrlToClipboard,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OPEN_FRAME_IN_NEW_WINDOW")]
    OpenFrameInNewWindow,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_GO_BACK")]
    GoBack,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_GO_FORWARD")]
    GoForward,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_STOP")]
    Stop,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_RELOAD")]
    Reload,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_COPY")]
    Copy,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_CUT")]
    Cut,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_PASTE")]
    Paste,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_DELETE")]
    Delete,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_SELECT_ALL")]
    SelectAll,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_INPUT_METHODS")]
    InputMethods,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_UNICODE")]
    Unicode,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_SPELLING_GUESS")]
    SpellingGuess,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_NO_GUESSES_FOUND")]
    NoGuessesFound,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_IGNORE_SPELLING")]
    IgnoreSpelling,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_LEARN_SPELLING")]
    LearnSpelling,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_IGNORE_GRAMMAR")]
    IgnoreGrammar,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_FONT_MENU")]
    FontMenu,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_BOLD")]
    Bold,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_ITALIC")]
    Italic,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_UNDERLINE")]
    Underline,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OUTLINE")]
    Outline,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_INSPECT_ELEMENT")]
    InspectElement,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OPEN_VIDEO_IN_NEW_WINDOW")]
    OpenVideoInNewWindow,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OPEN_AUDIO_IN_NEW_WINDOW")]
    OpenAudioInNewWindow,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_COPY_VIDEO_LINK_TO_CLIPBOARD")]
    CopyVideoLinkToClipboard,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_COPY_AUDIO_LINK_TO_CLIPBOARD")]
    CopyAudioLinkToClipboard,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_CONTROLS")]
    ToggleMediaControls,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_LOOP")]
    ToggleMediaLoop,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_ENTER_VIDEO_FULLSCREEN")]
    EnterVideoFullscreen,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PLAY")]
    MediaPlay,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PAUSE")]
    MediaPause,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_MEDIA_MUTE")]
    MediaMute,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_VIDEO_TO_DISK")]
    DownloadVideoToDisk,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_AUDIO_TO_DISK")]
    DownloadAudioToDisk,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_INSERT_EMOJI")]
    InsertEmoji,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_PASTE_AS_PLAIN_TEXT")]
    PasteAsPlainText,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_CUSTOM")]
    Custom,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ContextMenuAction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ContextMenuAction::{}",
            match *self {
                ContextMenuAction::NoAction => "NoAction",
                ContextMenuAction::OpenLink => "OpenLink",
                ContextMenuAction::OpenLinkInNewWindow => "OpenLinkInNewWindow",
                ContextMenuAction::DownloadLinkToDisk => "DownloadLinkToDisk",
                ContextMenuAction::CopyLinkToClipboard => "CopyLinkToClipboard",
                ContextMenuAction::OpenImageInNewWindow => "OpenImageInNewWindow",
                ContextMenuAction::DownloadImageToDisk => "DownloadImageToDisk",
                ContextMenuAction::CopyImageToClipboard => "CopyImageToClipboard",
                ContextMenuAction::CopyImageUrlToClipboard => "CopyImageUrlToClipboard",
                ContextMenuAction::OpenFrameInNewWindow => "OpenFrameInNewWindow",
                ContextMenuAction::GoBack => "GoBack",
                ContextMenuAction::GoForward => "GoForward",
                ContextMenuAction::Stop => "Stop",
                ContextMenuAction::Reload => "Reload",
                ContextMenuAction::Copy => "Copy",
                ContextMenuAction::Cut => "Cut",
                ContextMenuAction::Paste => "Paste",
                ContextMenuAction::Delete => "Delete",
                ContextMenuAction::SelectAll => "SelectAll",
                ContextMenuAction::InputMethods => "InputMethods",
                ContextMenuAction::Unicode => "Unicode",
                ContextMenuAction::SpellingGuess => "SpellingGuess",
                ContextMenuAction::NoGuessesFound => "NoGuessesFound",
                ContextMenuAction::IgnoreSpelling => "IgnoreSpelling",
                ContextMenuAction::LearnSpelling => "LearnSpelling",
                ContextMenuAction::IgnoreGrammar => "IgnoreGrammar",
                ContextMenuAction::FontMenu => "FontMenu",
                ContextMenuAction::Bold => "Bold",
                ContextMenuAction::Italic => "Italic",
                ContextMenuAction::Underline => "Underline",
                ContextMenuAction::Outline => "Outline",
                ContextMenuAction::InspectElement => "InspectElement",
                ContextMenuAction::OpenVideoInNewWindow => "OpenVideoInNewWindow",
                ContextMenuAction::OpenAudioInNewWindow => "OpenAudioInNewWindow",
                ContextMenuAction::CopyVideoLinkToClipboard => "CopyVideoLinkToClipboard",
                ContextMenuAction::CopyAudioLinkToClipboard => "CopyAudioLinkToClipboard",
                ContextMenuAction::ToggleMediaControls => "ToggleMediaControls",
                ContextMenuAction::ToggleMediaLoop => "ToggleMediaLoop",
                ContextMenuAction::EnterVideoFullscreen => "EnterVideoFullscreen",
                ContextMenuAction::MediaPlay => "MediaPlay",
                ContextMenuAction::MediaPause => "MediaPause",
                ContextMenuAction::MediaMute => "MediaMute",
                ContextMenuAction::DownloadVideoToDisk => "DownloadVideoToDisk",
                ContextMenuAction::DownloadAudioToDisk => "DownloadAudioToDisk",
                ContextMenuAction::InsertEmoji => "InsertEmoji",
                ContextMenuAction::PasteAsPlainText => "PasteAsPlainText",
                ContextMenuAction::Custom => "Custom",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ContextMenuAction {
    type GlibType = ffi::WebKitContextMenuAction;

    fn to_glib(&self) -> ffi::WebKitContextMenuAction {
        match *self {
            ContextMenuAction::NoAction => ffi::WEBKIT_CONTEXT_MENU_ACTION_NO_ACTION,
            ContextMenuAction::OpenLink => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK,
            ContextMenuAction::OpenLinkInNewWindow => {
                ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK_IN_NEW_WINDOW
            }
            ContextMenuAction::DownloadLinkToDisk => {
                ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_LINK_TO_DISK
            }
            ContextMenuAction::CopyLinkToClipboard => {
                ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_LINK_TO_CLIPBOARD
            }
            ContextMenuAction::OpenImageInNewWindow => {
                ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_IMAGE_IN_NEW_WINDOW
            }
            ContextMenuAction::DownloadImageToDisk => {
                ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_IMAGE_TO_DISK
            }
            ContextMenuAction::CopyImageToClipboard => {
                ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_IMAGE_TO_CLIPBOARD
            }
            ContextMenuAction::CopyImageUrlToClipboard => {
                ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_IMAGE_URL_TO_CLIPBOARD
            }
            ContextMenuAction::OpenFrameInNewWindow => {
                ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_FRAME_IN_NEW_WINDOW
            }
            ContextMenuAction::GoBack => ffi::WEBKIT_CONTEXT_MENU_ACTION_GO_BACK,
            ContextMenuAction::GoForward => ffi::WEBKIT_CONTEXT_MENU_ACTION_GO_FORWARD,
            ContextMenuAction::Stop => ffi::WEBKIT_CONTEXT_MENU_ACTION_STOP,
            ContextMenuAction::Reload => ffi::WEBKIT_CONTEXT_MENU_ACTION_RELOAD,
            ContextMenuAction::Copy => ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY,
            ContextMenuAction::Cut => ffi::WEBKIT_CONTEXT_MENU_ACTION_CUT,
            ContextMenuAction::Paste => ffi::WEBKIT_CONTEXT_MENU_ACTION_PASTE,
            ContextMenuAction::Delete => ffi::WEBKIT_CONTEXT_MENU_ACTION_DELETE,
            ContextMenuAction::SelectAll => ffi::WEBKIT_CONTEXT_MENU_ACTION_SELECT_ALL,
            ContextMenuAction::InputMethods => ffi::WEBKIT_CONTEXT_MENU_ACTION_INPUT_METHODS,
            ContextMenuAction::Unicode => ffi::WEBKIT_CONTEXT_MENU_ACTION_UNICODE,
            ContextMenuAction::SpellingGuess => ffi::WEBKIT_CONTEXT_MENU_ACTION_SPELLING_GUESS,
            ContextMenuAction::NoGuessesFound => ffi::WEBKIT_CONTEXT_MENU_ACTION_NO_GUESSES_FOUND,
            ContextMenuAction::IgnoreSpelling => ffi::WEBKIT_CONTEXT_MENU_ACTION_IGNORE_SPELLING,
            ContextMenuAction::LearnSpelling => ffi::WEBKIT_CONTEXT_MENU_ACTION_LEARN_SPELLING,
            ContextMenuAction::IgnoreGrammar => ffi::WEBKIT_CONTEXT_MENU_ACTION_IGNORE_GRAMMAR,
            ContextMenuAction::FontMenu => ffi::WEBKIT_CONTEXT_MENU_ACTION_FONT_MENU,
            ContextMenuAction::Bold => ffi::WEBKIT_CONTEXT_MENU_ACTION_BOLD,
            ContextMenuAction::Italic => ffi::WEBKIT_CONTEXT_MENU_ACTION_ITALIC,
            ContextMenuAction::Underline => ffi::WEBKIT_CONTEXT_MENU_ACTION_UNDERLINE,
            ContextMenuAction::Outline => ffi::WEBKIT_CONTEXT_MENU_ACTION_OUTLINE,
            ContextMenuAction::InspectElement => ffi::WEBKIT_CONTEXT_MENU_ACTION_INSPECT_ELEMENT,
            ContextMenuAction::OpenVideoInNewWindow => {
                ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_VIDEO_IN_NEW_WINDOW
            }
            ContextMenuAction::OpenAudioInNewWindow => {
                ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_AUDIO_IN_NEW_WINDOW
            }
            ContextMenuAction::CopyVideoLinkToClipboard => {
                ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_VIDEO_LINK_TO_CLIPBOARD
            }
            ContextMenuAction::CopyAudioLinkToClipboard => {
                ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_AUDIO_LINK_TO_CLIPBOARD
            }
            ContextMenuAction::ToggleMediaControls => {
                ffi::WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_CONTROLS
            }
            ContextMenuAction::ToggleMediaLoop => ffi::WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_LOOP,
            ContextMenuAction::EnterVideoFullscreen => {
                ffi::WEBKIT_CONTEXT_MENU_ACTION_ENTER_VIDEO_FULLSCREEN
            }
            ContextMenuAction::MediaPlay => ffi::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PLAY,
            ContextMenuAction::MediaPause => ffi::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PAUSE,
            ContextMenuAction::MediaMute => ffi::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_MUTE,
            ContextMenuAction::DownloadVideoToDisk => {
                ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_VIDEO_TO_DISK
            }
            ContextMenuAction::DownloadAudioToDisk => {
                ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_AUDIO_TO_DISK
            }
            ContextMenuAction::InsertEmoji => ffi::WEBKIT_CONTEXT_MENU_ACTION_INSERT_EMOJI,
            ContextMenuAction::PasteAsPlainText => {
                ffi::WEBKIT_CONTEXT_MENU_ACTION_PASTE_AS_PLAIN_TEXT
            }
            ContextMenuAction::Custom => ffi::WEBKIT_CONTEXT_MENU_ACTION_CUSTOM,
            ContextMenuAction::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitContextMenuAction> for ContextMenuAction {
    unsafe fn from_glib(value: ffi::WebKitContextMenuAction) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ContextMenuAction::NoAction,
            1 => ContextMenuAction::OpenLink,
            2 => ContextMenuAction::OpenLinkInNewWindow,
            3 => ContextMenuAction::DownloadLinkToDisk,
            4 => ContextMenuAction::CopyLinkToClipboard,
            5 => ContextMenuAction::OpenImageInNewWindow,
            6 => ContextMenuAction::DownloadImageToDisk,
            7 => ContextMenuAction::CopyImageToClipboard,
            8 => ContextMenuAction::CopyImageUrlToClipboard,
            9 => ContextMenuAction::OpenFrameInNewWindow,
            10 => ContextMenuAction::GoBack,
            11 => ContextMenuAction::GoForward,
            12 => ContextMenuAction::Stop,
            13 => ContextMenuAction::Reload,
            14 => ContextMenuAction::Copy,
            15 => ContextMenuAction::Cut,
            16 => ContextMenuAction::Paste,
            17 => ContextMenuAction::Delete,
            18 => ContextMenuAction::SelectAll,
            19 => ContextMenuAction::InputMethods,
            20 => ContextMenuAction::Unicode,
            21 => ContextMenuAction::SpellingGuess,
            22 => ContextMenuAction::NoGuessesFound,
            23 => ContextMenuAction::IgnoreSpelling,
            24 => ContextMenuAction::LearnSpelling,
            25 => ContextMenuAction::IgnoreGrammar,
            26 => ContextMenuAction::FontMenu,
            27 => ContextMenuAction::Bold,
            28 => ContextMenuAction::Italic,
            29 => ContextMenuAction::Underline,
            30 => ContextMenuAction::Outline,
            31 => ContextMenuAction::InspectElement,
            32 => ContextMenuAction::OpenVideoInNewWindow,
            33 => ContextMenuAction::OpenAudioInNewWindow,
            34 => ContextMenuAction::CopyVideoLinkToClipboard,
            35 => ContextMenuAction::CopyAudioLinkToClipboard,
            36 => ContextMenuAction::ToggleMediaControls,
            37 => ContextMenuAction::ToggleMediaLoop,
            38 => ContextMenuAction::EnterVideoFullscreen,
            39 => ContextMenuAction::MediaPlay,
            40 => ContextMenuAction::MediaPause,
            41 => ContextMenuAction::MediaMute,
            42 => ContextMenuAction::DownloadVideoToDisk,
            43 => ContextMenuAction::DownloadAudioToDisk,
            44 => ContextMenuAction::InsertEmoji,
            45 => ContextMenuAction::PasteAsPlainText,
            10000 => ContextMenuAction::Custom,
            value => ContextMenuAction::__Unknown(value),
        }
    }
}

impl StaticType for ContextMenuAction {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_context_menu_action_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ContextMenuAction {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ContextMenuAction {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ContextMenuAction {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitCookieAcceptPolicy")]
pub enum CookieAcceptPolicy {
    #[doc(alias = "WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS")]
    Always,
    #[doc(alias = "WEBKIT_COOKIE_POLICY_ACCEPT_NEVER")]
    Never,
    #[doc(alias = "WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY")]
    NoThirdParty,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CookieAcceptPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CookieAcceptPolicy::{}",
            match *self {
                CookieAcceptPolicy::Always => "Always",
                CookieAcceptPolicy::Never => "Never",
                CookieAcceptPolicy::NoThirdParty => "NoThirdParty",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CookieAcceptPolicy {
    type GlibType = ffi::WebKitCookieAcceptPolicy;

    fn to_glib(&self) -> ffi::WebKitCookieAcceptPolicy {
        match *self {
            CookieAcceptPolicy::Always => ffi::WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS,
            CookieAcceptPolicy::Never => ffi::WEBKIT_COOKIE_POLICY_ACCEPT_NEVER,
            CookieAcceptPolicy::NoThirdParty => ffi::WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY,
            CookieAcceptPolicy::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitCookieAcceptPolicy> for CookieAcceptPolicy {
    unsafe fn from_glib(value: ffi::WebKitCookieAcceptPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CookieAcceptPolicy::Always,
            1 => CookieAcceptPolicy::Never,
            2 => CookieAcceptPolicy::NoThirdParty,
            value => CookieAcceptPolicy::__Unknown(value),
        }
    }
}

impl StaticType for CookieAcceptPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_cookie_accept_policy_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CookieAcceptPolicy {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CookieAcceptPolicy {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CookieAcceptPolicy {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitCookiePersistentStorage")]
pub enum CookiePersistentStorage {
    #[doc(alias = "WEBKIT_COOKIE_PERSISTENT_STORAGE_TEXT")]
    Text,
    #[doc(alias = "WEBKIT_COOKIE_PERSISTENT_STORAGE_SQLITE")]
    Sqlite,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CookiePersistentStorage {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CookiePersistentStorage::{}",
            match *self {
                CookiePersistentStorage::Text => "Text",
                CookiePersistentStorage::Sqlite => "Sqlite",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CookiePersistentStorage {
    type GlibType = ffi::WebKitCookiePersistentStorage;

    fn to_glib(&self) -> ffi::WebKitCookiePersistentStorage {
        match *self {
            CookiePersistentStorage::Text => ffi::WEBKIT_COOKIE_PERSISTENT_STORAGE_TEXT,
            CookiePersistentStorage::Sqlite => ffi::WEBKIT_COOKIE_PERSISTENT_STORAGE_SQLITE,
            CookiePersistentStorage::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitCookiePersistentStorage> for CookiePersistentStorage {
    unsafe fn from_glib(value: ffi::WebKitCookiePersistentStorage) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CookiePersistentStorage::Text,
            1 => CookiePersistentStorage::Sqlite,
            value => CookiePersistentStorage::__Unknown(value),
        }
    }
}

impl StaticType for CookiePersistentStorage {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_cookie_persistent_storage_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CookiePersistentStorage {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CookiePersistentStorage {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CookiePersistentStorage {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitCredentialPersistence")]
pub enum CredentialPersistence {
    #[doc(alias = "WEBKIT_CREDENTIAL_PERSISTENCE_NONE")]
    None,
    #[doc(alias = "WEBKIT_CREDENTIAL_PERSISTENCE_FOR_SESSION")]
    ForSession,
    #[doc(alias = "WEBKIT_CREDENTIAL_PERSISTENCE_PERMANENT")]
    Permanent,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
impl fmt::Display for CredentialPersistence {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CredentialPersistence::{}",
            match *self {
                CredentialPersistence::None => "None",
                CredentialPersistence::ForSession => "ForSession",
                CredentialPersistence::Permanent => "Permanent",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
#[doc(hidden)]
impl ToGlib for CredentialPersistence {
    type GlibType = ffi::WebKitCredentialPersistence;

    fn to_glib(&self) -> ffi::WebKitCredentialPersistence {
        match *self {
            CredentialPersistence::None => ffi::WEBKIT_CREDENTIAL_PERSISTENCE_NONE,
            CredentialPersistence::ForSession => ffi::WEBKIT_CREDENTIAL_PERSISTENCE_FOR_SESSION,
            CredentialPersistence::Permanent => ffi::WEBKIT_CREDENTIAL_PERSISTENCE_PERMANENT,
            CredentialPersistence::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitCredentialPersistence> for CredentialPersistence {
    unsafe fn from_glib(value: ffi::WebKitCredentialPersistence) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CredentialPersistence::None,
            1 => CredentialPersistence::ForSession,
            2 => CredentialPersistence::Permanent,
            value => CredentialPersistence::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
impl StaticType for CredentialPersistence {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_credential_persistence_get_type()) }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
impl<'a> FromValueOptional<'a> for CredentialPersistence {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
impl<'a> FromValue<'a> for CredentialPersistence {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
impl SetValue for CredentialPersistence {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitDownloadError")]
pub enum DownloadError {
    #[doc(alias = "WEBKIT_DOWNLOAD_ERROR_NETWORK")]
    Network,
    #[doc(alias = "WEBKIT_DOWNLOAD_ERROR_CANCELLED_BY_USER")]
    CancelledByUser,
    #[doc(alias = "WEBKIT_DOWNLOAD_ERROR_DESTINATION")]
    Destination,
    #[doc(hidden)]
    __Unknown(i32),
}

impl DownloadError {
    #[doc(alias = "webkit_download_error_quark")]
    pub fn quark() -> glib::Quark {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::webkit_download_error_quark()) }
    }
}

impl fmt::Display for DownloadError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DownloadError::{}",
            match *self {
                DownloadError::Network => "Network",
                DownloadError::CancelledByUser => "CancelledByUser",
                DownloadError::Destination => "Destination",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for DownloadError {
    type GlibType = ffi::WebKitDownloadError;

    fn to_glib(&self) -> ffi::WebKitDownloadError {
        match *self {
            DownloadError::Network => ffi::WEBKIT_DOWNLOAD_ERROR_NETWORK,
            DownloadError::CancelledByUser => ffi::WEBKIT_DOWNLOAD_ERROR_CANCELLED_BY_USER,
            DownloadError::Destination => ffi::WEBKIT_DOWNLOAD_ERROR_DESTINATION,
            DownloadError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitDownloadError> for DownloadError {
    unsafe fn from_glib(value: ffi::WebKitDownloadError) -> Self {
        skip_assert_initialized!();
        match value {
            499 => DownloadError::Network,
            400 => DownloadError::CancelledByUser,
            401 => DownloadError::Destination,
            value => DownloadError::__Unknown(value),
        }
    }
}

impl ErrorDomain for DownloadError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
            once_cell::sync::Lazy::new(|| unsafe {
                glib::ffi::g_quark_from_static_string(b"WebKitDownloadError\0".as_ptr() as *const _)
            });
        unsafe { from_glib(*QUARK) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            499 => Some(DownloadError::Network),
            400 => Some(DownloadError::CancelledByUser),
            401 => Some(DownloadError::Destination),
            value => Some(DownloadError::__Unknown(value)),
        }
    }
}

impl StaticType for DownloadError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_download_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DownloadError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DownloadError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DownloadError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitFaviconDatabaseError")]
pub enum FaviconDatabaseError {
    #[doc(alias = "WEBKIT_FAVICON_DATABASE_ERROR_NOT_INITIALIZED")]
    NotInitialized,
    #[doc(alias = "WEBKIT_FAVICON_DATABASE_ERROR_FAVICON_NOT_FOUND")]
    FaviconNotFound,
    #[doc(alias = "WEBKIT_FAVICON_DATABASE_ERROR_FAVICON_UNKNOWN")]
    FaviconUnknown,
    #[doc(hidden)]
    __Unknown(i32),
}

impl FaviconDatabaseError {
    #[doc(alias = "webkit_favicon_database_error_quark")]
    pub fn quark() -> glib::Quark {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::webkit_favicon_database_error_quark()) }
    }
}

impl fmt::Display for FaviconDatabaseError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FaviconDatabaseError::{}",
            match *self {
                FaviconDatabaseError::NotInitialized => "NotInitialized",
                FaviconDatabaseError::FaviconNotFound => "FaviconNotFound",
                FaviconDatabaseError::FaviconUnknown => "FaviconUnknown",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for FaviconDatabaseError {
    type GlibType = ffi::WebKitFaviconDatabaseError;

    fn to_glib(&self) -> ffi::WebKitFaviconDatabaseError {
        match *self {
            FaviconDatabaseError::NotInitialized => {
                ffi::WEBKIT_FAVICON_DATABASE_ERROR_NOT_INITIALIZED
            }
            FaviconDatabaseError::FaviconNotFound => {
                ffi::WEBKIT_FAVICON_DATABASE_ERROR_FAVICON_NOT_FOUND
            }
            FaviconDatabaseError::FaviconUnknown => {
                ffi::WEBKIT_FAVICON_DATABASE_ERROR_FAVICON_UNKNOWN
            }
            FaviconDatabaseError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitFaviconDatabaseError> for FaviconDatabaseError {
    unsafe fn from_glib(value: ffi::WebKitFaviconDatabaseError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => FaviconDatabaseError::NotInitialized,
            1 => FaviconDatabaseError::FaviconNotFound,
            2 => FaviconDatabaseError::FaviconUnknown,
            value => FaviconDatabaseError::__Unknown(value),
        }
    }
}

impl ErrorDomain for FaviconDatabaseError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
            once_cell::sync::Lazy::new(|| unsafe {
                glib::ffi::g_quark_from_static_string(
                    b"WebKitFaviconDatabaseError\0".as_ptr() as *const _
                )
            });
        unsafe { from_glib(*QUARK) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(FaviconDatabaseError::NotInitialized),
            1 => Some(FaviconDatabaseError::FaviconNotFound),
            2 => Some(FaviconDatabaseError::FaviconUnknown),
            value => Some(FaviconDatabaseError::__Unknown(value)),
        }
    }
}

impl StaticType for FaviconDatabaseError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_favicon_database_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FaviconDatabaseError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FaviconDatabaseError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FaviconDatabaseError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitHardwareAccelerationPolicy")]
pub enum HardwareAccelerationPolicy {
    #[doc(alias = "WEBKIT_HARDWARE_ACCELERATION_POLICY_ON_DEMAND")]
    OnDemand,
    #[doc(alias = "WEBKIT_HARDWARE_ACCELERATION_POLICY_ALWAYS")]
    Always,
    #[doc(alias = "WEBKIT_HARDWARE_ACCELERATION_POLICY_NEVER")]
    Never,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
impl fmt::Display for HardwareAccelerationPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "HardwareAccelerationPolicy::{}",
            match *self {
                HardwareAccelerationPolicy::OnDemand => "OnDemand",
                HardwareAccelerationPolicy::Always => "Always",
                HardwareAccelerationPolicy::Never => "Never",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
#[doc(hidden)]
impl ToGlib for HardwareAccelerationPolicy {
    type GlibType = ffi::WebKitHardwareAccelerationPolicy;

    fn to_glib(&self) -> ffi::WebKitHardwareAccelerationPolicy {
        match *self {
            HardwareAccelerationPolicy::OnDemand => {
                ffi::WEBKIT_HARDWARE_ACCELERATION_POLICY_ON_DEMAND
            }
            HardwareAccelerationPolicy::Always => ffi::WEBKIT_HARDWARE_ACCELERATION_POLICY_ALWAYS,
            HardwareAccelerationPolicy::Never => ffi::WEBKIT_HARDWARE_ACCELERATION_POLICY_NEVER,
            HardwareAccelerationPolicy::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitHardwareAccelerationPolicy> for HardwareAccelerationPolicy {
    unsafe fn from_glib(value: ffi::WebKitHardwareAccelerationPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => HardwareAccelerationPolicy::OnDemand,
            1 => HardwareAccelerationPolicy::Always,
            2 => HardwareAccelerationPolicy::Never,
            value => HardwareAccelerationPolicy::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
impl StaticType for HardwareAccelerationPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_hardware_acceleration_policy_get_type()) }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
impl<'a> FromValueOptional<'a> for HardwareAccelerationPolicy {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
impl<'a> FromValue<'a> for HardwareAccelerationPolicy {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
impl SetValue for HardwareAccelerationPolicy {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitInputPurpose")]
pub enum InputPurpose {
    #[doc(alias = "WEBKIT_INPUT_PURPOSE_FREE_FORM")]
    FreeForm,
    #[doc(alias = "WEBKIT_INPUT_PURPOSE_DIGITS")]
    Digits,
    #[doc(alias = "WEBKIT_INPUT_PURPOSE_NUMBER")]
    Number,
    #[doc(alias = "WEBKIT_INPUT_PURPOSE_PHONE")]
    Phone,
    #[doc(alias = "WEBKIT_INPUT_PURPOSE_URL")]
    Url,
    #[doc(alias = "WEBKIT_INPUT_PURPOSE_EMAIL")]
    Email,
    #[doc(alias = "WEBKIT_INPUT_PURPOSE_PASSWORD")]
    Password,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl fmt::Display for InputPurpose {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "InputPurpose::{}",
            match *self {
                InputPurpose::FreeForm => "FreeForm",
                InputPurpose::Digits => "Digits",
                InputPurpose::Number => "Number",
                InputPurpose::Phone => "Phone",
                InputPurpose::Url => "Url",
                InputPurpose::Email => "Email",
                InputPurpose::Password => "Password",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
#[doc(hidden)]
impl ToGlib for InputPurpose {
    type GlibType = ffi::WebKitInputPurpose;

    fn to_glib(&self) -> ffi::WebKitInputPurpose {
        match *self {
            InputPurpose::FreeForm => ffi::WEBKIT_INPUT_PURPOSE_FREE_FORM,
            InputPurpose::Digits => ffi::WEBKIT_INPUT_PURPOSE_DIGITS,
            InputPurpose::Number => ffi::WEBKIT_INPUT_PURPOSE_NUMBER,
            InputPurpose::Phone => ffi::WEBKIT_INPUT_PURPOSE_PHONE,
            InputPurpose::Url => ffi::WEBKIT_INPUT_PURPOSE_URL,
            InputPurpose::Email => ffi::WEBKIT_INPUT_PURPOSE_EMAIL,
            InputPurpose::Password => ffi::WEBKIT_INPUT_PURPOSE_PASSWORD,
            InputPurpose::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitInputPurpose> for InputPurpose {
    unsafe fn from_glib(value: ffi::WebKitInputPurpose) -> Self {
        skip_assert_initialized!();
        match value {
            0 => InputPurpose::FreeForm,
            1 => InputPurpose::Digits,
            2 => InputPurpose::Number,
            3 => InputPurpose::Phone,
            4 => InputPurpose::Url,
            5 => InputPurpose::Email,
            6 => InputPurpose::Password,
            value => InputPurpose::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl StaticType for InputPurpose {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_input_purpose_get_type()) }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl<'a> FromValueOptional<'a> for InputPurpose {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl<'a> FromValue<'a> for InputPurpose {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl SetValue for InputPurpose {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitInsecureContentEvent")]
pub enum InsecureContentEvent {
    #[doc(alias = "WEBKIT_INSECURE_CONTENT_RUN")]
    Run,
    #[doc(alias = "WEBKIT_INSECURE_CONTENT_DISPLAYED")]
    Displayed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for InsecureContentEvent {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "InsecureContentEvent::{}",
            match *self {
                InsecureContentEvent::Run => "Run",
                InsecureContentEvent::Displayed => "Displayed",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for InsecureContentEvent {
    type GlibType = ffi::WebKitInsecureContentEvent;

    fn to_glib(&self) -> ffi::WebKitInsecureContentEvent {
        match *self {
            InsecureContentEvent::Run => ffi::WEBKIT_INSECURE_CONTENT_RUN,
            InsecureContentEvent::Displayed => ffi::WEBKIT_INSECURE_CONTENT_DISPLAYED,
            InsecureContentEvent::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitInsecureContentEvent> for InsecureContentEvent {
    unsafe fn from_glib(value: ffi::WebKitInsecureContentEvent) -> Self {
        skip_assert_initialized!();
        match value {
            0 => InsecureContentEvent::Run,
            1 => InsecureContentEvent::Displayed,
            value => InsecureContentEvent::__Unknown(value),
        }
    }
}

impl StaticType for InsecureContentEvent {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_insecure_content_event_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for InsecureContentEvent {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for InsecureContentEvent {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for InsecureContentEvent {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitJavascriptError")]
pub enum JavascriptError {
    #[doc(alias = "WEBKIT_JAVASCRIPT_ERROR_SCRIPT_FAILED")]
    Failed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl JavascriptError {
    #[doc(alias = "webkit_javascript_error_quark")]
    pub fn quark() -> glib::Quark {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::webkit_javascript_error_quark()) }
    }
}

impl fmt::Display for JavascriptError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "JavascriptError::{}",
            match *self {
                JavascriptError::Failed => "Failed",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for JavascriptError {
    type GlibType = ffi::WebKitJavascriptError;

    fn to_glib(&self) -> ffi::WebKitJavascriptError {
        match *self {
            JavascriptError::Failed => ffi::WEBKIT_JAVASCRIPT_ERROR_SCRIPT_FAILED,
            JavascriptError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitJavascriptError> for JavascriptError {
    unsafe fn from_glib(value: ffi::WebKitJavascriptError) -> Self {
        skip_assert_initialized!();
        match value {
            699 => JavascriptError::Failed,
            value => JavascriptError::__Unknown(value),
        }
    }
}

impl ErrorDomain for JavascriptError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
            once_cell::sync::Lazy::new(|| unsafe {
                glib::ffi::g_quark_from_static_string(
                    b"WebKitJavascriptError\0".as_ptr() as *const _
                )
            });
        unsafe { from_glib(*QUARK) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            699 => Some(JavascriptError::Failed),
            _ => Some(JavascriptError::Failed),
        }
    }
}

impl StaticType for JavascriptError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_javascript_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for JavascriptError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for JavascriptError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for JavascriptError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitLoadEvent")]
pub enum LoadEvent {
    #[doc(alias = "WEBKIT_LOAD_STARTED")]
    Started,
    #[doc(alias = "WEBKIT_LOAD_REDIRECTED")]
    Redirected,
    #[doc(alias = "WEBKIT_LOAD_COMMITTED")]
    Committed,
    #[doc(alias = "WEBKIT_LOAD_FINISHED")]
    Finished,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for LoadEvent {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "LoadEvent::{}",
            match *self {
                LoadEvent::Started => "Started",
                LoadEvent::Redirected => "Redirected",
                LoadEvent::Committed => "Committed",
                LoadEvent::Finished => "Finished",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for LoadEvent {
    type GlibType = ffi::WebKitLoadEvent;

    fn to_glib(&self) -> ffi::WebKitLoadEvent {
        match *self {
            LoadEvent::Started => ffi::WEBKIT_LOAD_STARTED,
            LoadEvent::Redirected => ffi::WEBKIT_LOAD_REDIRECTED,
            LoadEvent::Committed => ffi::WEBKIT_LOAD_COMMITTED,
            LoadEvent::Finished => ffi::WEBKIT_LOAD_FINISHED,
            LoadEvent::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitLoadEvent> for LoadEvent {
    unsafe fn from_glib(value: ffi::WebKitLoadEvent) -> Self {
        skip_assert_initialized!();
        match value {
            0 => LoadEvent::Started,
            1 => LoadEvent::Redirected,
            2 => LoadEvent::Committed,
            3 => LoadEvent::Finished,
            value => LoadEvent::__Unknown(value),
        }
    }
}

impl StaticType for LoadEvent {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_load_event_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for LoadEvent {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for LoadEvent {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for LoadEvent {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitNavigationType")]
pub enum NavigationType {
    #[doc(alias = "WEBKIT_NAVIGATION_TYPE_LINK_CLICKED")]
    LinkClicked,
    #[doc(alias = "WEBKIT_NAVIGATION_TYPE_FORM_SUBMITTED")]
    FormSubmitted,
    #[doc(alias = "WEBKIT_NAVIGATION_TYPE_BACK_FORWARD")]
    BackForward,
    #[doc(alias = "WEBKIT_NAVIGATION_TYPE_RELOAD")]
    Reload,
    #[doc(alias = "WEBKIT_NAVIGATION_TYPE_FORM_RESUBMITTED")]
    FormResubmitted,
    #[doc(alias = "WEBKIT_NAVIGATION_TYPE_OTHER")]
    Other,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for NavigationType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "NavigationType::{}",
            match *self {
                NavigationType::LinkClicked => "LinkClicked",
                NavigationType::FormSubmitted => "FormSubmitted",
                NavigationType::BackForward => "BackForward",
                NavigationType::Reload => "Reload",
                NavigationType::FormResubmitted => "FormResubmitted",
                NavigationType::Other => "Other",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for NavigationType {
    type GlibType = ffi::WebKitNavigationType;

    fn to_glib(&self) -> ffi::WebKitNavigationType {
        match *self {
            NavigationType::LinkClicked => ffi::WEBKIT_NAVIGATION_TYPE_LINK_CLICKED,
            NavigationType::FormSubmitted => ffi::WEBKIT_NAVIGATION_TYPE_FORM_SUBMITTED,
            NavigationType::BackForward => ffi::WEBKIT_NAVIGATION_TYPE_BACK_FORWARD,
            NavigationType::Reload => ffi::WEBKIT_NAVIGATION_TYPE_RELOAD,
            NavigationType::FormResubmitted => ffi::WEBKIT_NAVIGATION_TYPE_FORM_RESUBMITTED,
            NavigationType::Other => ffi::WEBKIT_NAVIGATION_TYPE_OTHER,
            NavigationType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitNavigationType> for NavigationType {
    unsafe fn from_glib(value: ffi::WebKitNavigationType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => NavigationType::LinkClicked,
            1 => NavigationType::FormSubmitted,
            2 => NavigationType::BackForward,
            3 => NavigationType::Reload,
            4 => NavigationType::FormResubmitted,
            5 => NavigationType::Other,
            value => NavigationType::__Unknown(value),
        }
    }
}

impl StaticType for NavigationType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_navigation_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for NavigationType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for NavigationType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for NavigationType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitNetworkError")]
pub enum NetworkError {
    #[doc(alias = "WEBKIT_NETWORK_ERROR_FAILED")]
    Failed,
    #[doc(alias = "WEBKIT_NETWORK_ERROR_TRANSPORT")]
    Transport,
    #[doc(alias = "WEBKIT_NETWORK_ERROR_UNKNOWN_PROTOCOL")]
    UnknownProtocol,
    #[doc(alias = "WEBKIT_NETWORK_ERROR_CANCELLED")]
    Cancelled,
    #[doc(alias = "WEBKIT_NETWORK_ERROR_FILE_DOES_NOT_EXIST")]
    FileDoesNotExist,
    #[doc(hidden)]
    __Unknown(i32),
}

impl NetworkError {
    #[doc(alias = "webkit_network_error_quark")]
    pub fn quark() -> glib::Quark {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::webkit_network_error_quark()) }
    }
}

impl fmt::Display for NetworkError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "NetworkError::{}",
            match *self {
                NetworkError::Failed => "Failed",
                NetworkError::Transport => "Transport",
                NetworkError::UnknownProtocol => "UnknownProtocol",
                NetworkError::Cancelled => "Cancelled",
                NetworkError::FileDoesNotExist => "FileDoesNotExist",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for NetworkError {
    type GlibType = ffi::WebKitNetworkError;

    fn to_glib(&self) -> ffi::WebKitNetworkError {
        match *self {
            NetworkError::Failed => ffi::WEBKIT_NETWORK_ERROR_FAILED,
            NetworkError::Transport => ffi::WEBKIT_NETWORK_ERROR_TRANSPORT,
            NetworkError::UnknownProtocol => ffi::WEBKIT_NETWORK_ERROR_UNKNOWN_PROTOCOL,
            NetworkError::Cancelled => ffi::WEBKIT_NETWORK_ERROR_CANCELLED,
            NetworkError::FileDoesNotExist => ffi::WEBKIT_NETWORK_ERROR_FILE_DOES_NOT_EXIST,
            NetworkError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitNetworkError> for NetworkError {
    unsafe fn from_glib(value: ffi::WebKitNetworkError) -> Self {
        skip_assert_initialized!();
        match value {
            399 => NetworkError::Failed,
            300 => NetworkError::Transport,
            301 => NetworkError::UnknownProtocol,
            302 => NetworkError::Cancelled,
            303 => NetworkError::FileDoesNotExist,
            value => NetworkError::__Unknown(value),
        }
    }
}

impl ErrorDomain for NetworkError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
            once_cell::sync::Lazy::new(|| unsafe {
                glib::ffi::g_quark_from_static_string(b"WebKitNetworkError\0".as_ptr() as *const _)
            });
        unsafe { from_glib(*QUARK) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            399 => Some(NetworkError::Failed),
            300 => Some(NetworkError::Transport),
            301 => Some(NetworkError::UnknownProtocol),
            302 => Some(NetworkError::Cancelled),
            303 => Some(NetworkError::FileDoesNotExist),
            _ => Some(NetworkError::Failed),
        }
    }
}

impl StaticType for NetworkError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_network_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for NetworkError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for NetworkError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for NetworkError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitNetworkProxyMode")]
pub enum NetworkProxyMode {
    #[doc(alias = "WEBKIT_NETWORK_PROXY_MODE_DEFAULT")]
    Default,
    #[doc(alias = "WEBKIT_NETWORK_PROXY_MODE_NO_PROXY")]
    NoProxy,
    #[doc(alias = "WEBKIT_NETWORK_PROXY_MODE_CUSTOM")]
    Custom,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
impl fmt::Display for NetworkProxyMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "NetworkProxyMode::{}",
            match *self {
                NetworkProxyMode::Default => "Default",
                NetworkProxyMode::NoProxy => "NoProxy",
                NetworkProxyMode::Custom => "Custom",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
#[doc(hidden)]
impl ToGlib for NetworkProxyMode {
    type GlibType = ffi::WebKitNetworkProxyMode;

    fn to_glib(&self) -> ffi::WebKitNetworkProxyMode {
        match *self {
            NetworkProxyMode::Default => ffi::WEBKIT_NETWORK_PROXY_MODE_DEFAULT,
            NetworkProxyMode::NoProxy => ffi::WEBKIT_NETWORK_PROXY_MODE_NO_PROXY,
            NetworkProxyMode::Custom => ffi::WEBKIT_NETWORK_PROXY_MODE_CUSTOM,
            NetworkProxyMode::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitNetworkProxyMode> for NetworkProxyMode {
    unsafe fn from_glib(value: ffi::WebKitNetworkProxyMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => NetworkProxyMode::Default,
            1 => NetworkProxyMode::NoProxy,
            2 => NetworkProxyMode::Custom,
            value => NetworkProxyMode::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
impl StaticType for NetworkProxyMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_network_proxy_mode_get_type()) }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
impl<'a> FromValueOptional<'a> for NetworkProxyMode {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
impl<'a> FromValue<'a> for NetworkProxyMode {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
impl SetValue for NetworkProxyMode {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitPluginError")]
pub enum PluginError {
    #[doc(alias = "WEBKIT_PLUGIN_ERROR_FAILED")]
    Failed,
    #[doc(alias = "WEBKIT_PLUGIN_ERROR_CANNOT_FIND_PLUGIN")]
    CannotFindPlugin,
    #[doc(alias = "WEBKIT_PLUGIN_ERROR_CANNOT_LOAD_PLUGIN")]
    CannotLoadPlugin,
    #[doc(alias = "WEBKIT_PLUGIN_ERROR_JAVA_UNAVAILABLE")]
    JavaUnavailable,
    #[doc(alias = "WEBKIT_PLUGIN_ERROR_CONNECTION_CANCELLED")]
    ConnectionCancelled,
    #[doc(alias = "WEBKIT_PLUGIN_ERROR_WILL_HANDLE_LOAD")]
    WillHandleLoad,
    #[doc(hidden)]
    __Unknown(i32),
}

impl PluginError {
    #[doc(alias = "webkit_plugin_error_quark")]
    pub fn quark() -> glib::Quark {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::webkit_plugin_error_quark()) }
    }
}

impl fmt::Display for PluginError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PluginError::{}",
            match *self {
                PluginError::Failed => "Failed",
                PluginError::CannotFindPlugin => "CannotFindPlugin",
                PluginError::CannotLoadPlugin => "CannotLoadPlugin",
                PluginError::JavaUnavailable => "JavaUnavailable",
                PluginError::ConnectionCancelled => "ConnectionCancelled",
                PluginError::WillHandleLoad => "WillHandleLoad",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PluginError {
    type GlibType = ffi::WebKitPluginError;

    fn to_glib(&self) -> ffi::WebKitPluginError {
        match *self {
            PluginError::Failed => ffi::WEBKIT_PLUGIN_ERROR_FAILED,
            PluginError::CannotFindPlugin => ffi::WEBKIT_PLUGIN_ERROR_CANNOT_FIND_PLUGIN,
            PluginError::CannotLoadPlugin => ffi::WEBKIT_PLUGIN_ERROR_CANNOT_LOAD_PLUGIN,
            PluginError::JavaUnavailable => ffi::WEBKIT_PLUGIN_ERROR_JAVA_UNAVAILABLE,
            PluginError::ConnectionCancelled => ffi::WEBKIT_PLUGIN_ERROR_CONNECTION_CANCELLED,
            PluginError::WillHandleLoad => ffi::WEBKIT_PLUGIN_ERROR_WILL_HANDLE_LOAD,
            PluginError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitPluginError> for PluginError {
    unsafe fn from_glib(value: ffi::WebKitPluginError) -> Self {
        skip_assert_initialized!();
        match value {
            299 => PluginError::Failed,
            200 => PluginError::CannotFindPlugin,
            201 => PluginError::CannotLoadPlugin,
            202 => PluginError::JavaUnavailable,
            203 => PluginError::ConnectionCancelled,
            204 => PluginError::WillHandleLoad,
            value => PluginError::__Unknown(value),
        }
    }
}

impl ErrorDomain for PluginError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
            once_cell::sync::Lazy::new(|| unsafe {
                glib::ffi::g_quark_from_static_string(b"WebKitPluginError\0".as_ptr() as *const _)
            });
        unsafe { from_glib(*QUARK) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            299 => Some(PluginError::Failed),
            200 => Some(PluginError::CannotFindPlugin),
            201 => Some(PluginError::CannotLoadPlugin),
            202 => Some(PluginError::JavaUnavailable),
            203 => Some(PluginError::ConnectionCancelled),
            204 => Some(PluginError::WillHandleLoad),
            _ => Some(PluginError::Failed),
        }
    }
}

impl StaticType for PluginError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_plugin_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PluginError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PluginError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PluginError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitPolicyDecisionType")]
pub enum PolicyDecisionType {
    #[doc(alias = "WEBKIT_POLICY_DECISION_TYPE_NAVIGATION_ACTION")]
    NavigationAction,
    #[doc(alias = "WEBKIT_POLICY_DECISION_TYPE_NEW_WINDOW_ACTION")]
    NewWindowAction,
    #[doc(alias = "WEBKIT_POLICY_DECISION_TYPE_RESPONSE")]
    Response,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PolicyDecisionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PolicyDecisionType::{}",
            match *self {
                PolicyDecisionType::NavigationAction => "NavigationAction",
                PolicyDecisionType::NewWindowAction => "NewWindowAction",
                PolicyDecisionType::Response => "Response",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PolicyDecisionType {
    type GlibType = ffi::WebKitPolicyDecisionType;

    fn to_glib(&self) -> ffi::WebKitPolicyDecisionType {
        match *self {
            PolicyDecisionType::NavigationAction => {
                ffi::WEBKIT_POLICY_DECISION_TYPE_NAVIGATION_ACTION
            }
            PolicyDecisionType::NewWindowAction => {
                ffi::WEBKIT_POLICY_DECISION_TYPE_NEW_WINDOW_ACTION
            }
            PolicyDecisionType::Response => ffi::WEBKIT_POLICY_DECISION_TYPE_RESPONSE,
            PolicyDecisionType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitPolicyDecisionType> for PolicyDecisionType {
    unsafe fn from_glib(value: ffi::WebKitPolicyDecisionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PolicyDecisionType::NavigationAction,
            1 => PolicyDecisionType::NewWindowAction,
            2 => PolicyDecisionType::Response,
            value => PolicyDecisionType::__Unknown(value),
        }
    }
}

impl StaticType for PolicyDecisionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_policy_decision_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PolicyDecisionType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PolicyDecisionType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PolicyDecisionType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitPolicyError")]
pub enum PolicyError {
    #[doc(alias = "WEBKIT_POLICY_ERROR_FAILED")]
    Failed,
    #[doc(alias = "WEBKIT_POLICY_ERROR_CANNOT_SHOW_MIME_TYPE")]
    CannotShowMimeType,
    #[doc(alias = "WEBKIT_POLICY_ERROR_CANNOT_SHOW_URI")]
    CannotShowUri,
    #[doc(alias = "WEBKIT_POLICY_ERROR_FRAME_LOAD_INTERRUPTED_BY_POLICY_CHANGE")]
    FrameLoadInterruptedByPolicyChange,
    #[doc(alias = "WEBKIT_POLICY_ERROR_CANNOT_USE_RESTRICTED_PORT")]
    CannotUseRestrictedPort,
    #[doc(hidden)]
    __Unknown(i32),
}

impl PolicyError {
    #[doc(alias = "webkit_policy_error_quark")]
    pub fn quark() -> glib::Quark {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::webkit_policy_error_quark()) }
    }
}

impl fmt::Display for PolicyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PolicyError::{}",
            match *self {
                PolicyError::Failed => "Failed",
                PolicyError::CannotShowMimeType => "CannotShowMimeType",
                PolicyError::CannotShowUri => "CannotShowUri",
                PolicyError::FrameLoadInterruptedByPolicyChange =>
                    "FrameLoadInterruptedByPolicyChange",
                PolicyError::CannotUseRestrictedPort => "CannotUseRestrictedPort",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PolicyError {
    type GlibType = ffi::WebKitPolicyError;

    fn to_glib(&self) -> ffi::WebKitPolicyError {
        match *self {
            PolicyError::Failed => ffi::WEBKIT_POLICY_ERROR_FAILED,
            PolicyError::CannotShowMimeType => ffi::WEBKIT_POLICY_ERROR_CANNOT_SHOW_MIME_TYPE,
            PolicyError::CannotShowUri => ffi::WEBKIT_POLICY_ERROR_CANNOT_SHOW_URI,
            PolicyError::FrameLoadInterruptedByPolicyChange => {
                ffi::WEBKIT_POLICY_ERROR_FRAME_LOAD_INTERRUPTED_BY_POLICY_CHANGE
            }
            PolicyError::CannotUseRestrictedPort => {
                ffi::WEBKIT_POLICY_ERROR_CANNOT_USE_RESTRICTED_PORT
            }
            PolicyError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitPolicyError> for PolicyError {
    unsafe fn from_glib(value: ffi::WebKitPolicyError) -> Self {
        skip_assert_initialized!();
        match value {
            199 => PolicyError::Failed,
            100 => PolicyError::CannotShowMimeType,
            101 => PolicyError::CannotShowUri,
            102 => PolicyError::FrameLoadInterruptedByPolicyChange,
            103 => PolicyError::CannotUseRestrictedPort,
            value => PolicyError::__Unknown(value),
        }
    }
}

impl ErrorDomain for PolicyError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
            once_cell::sync::Lazy::new(|| unsafe {
                glib::ffi::g_quark_from_static_string(b"WebKitPolicyError\0".as_ptr() as *const _)
            });
        unsafe { from_glib(*QUARK) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            199 => Some(PolicyError::Failed),
            100 => Some(PolicyError::CannotShowMimeType),
            101 => Some(PolicyError::CannotShowUri),
            102 => Some(PolicyError::FrameLoadInterruptedByPolicyChange),
            103 => Some(PolicyError::CannotUseRestrictedPort),
            _ => Some(PolicyError::Failed),
        }
    }
}

impl StaticType for PolicyError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_policy_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PolicyError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PolicyError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PolicyError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitPrintError")]
pub enum PrintError {
    #[doc(alias = "WEBKIT_PRINT_ERROR_GENERAL")]
    General,
    #[doc(alias = "WEBKIT_PRINT_ERROR_PRINTER_NOT_FOUND")]
    PrinterNotFound,
    #[doc(alias = "WEBKIT_PRINT_ERROR_INVALID_PAGE_RANGE")]
    InvalidPageRange,
    #[doc(hidden)]
    __Unknown(i32),
}

impl PrintError {
    #[doc(alias = "webkit_print_error_quark")]
    pub fn quark() -> glib::Quark {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::webkit_print_error_quark()) }
    }
}

impl fmt::Display for PrintError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PrintError::{}",
            match *self {
                PrintError::General => "General",
                PrintError::PrinterNotFound => "PrinterNotFound",
                PrintError::InvalidPageRange => "InvalidPageRange",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PrintError {
    type GlibType = ffi::WebKitPrintError;

    fn to_glib(&self) -> ffi::WebKitPrintError {
        match *self {
            PrintError::General => ffi::WEBKIT_PRINT_ERROR_GENERAL,
            PrintError::PrinterNotFound => ffi::WEBKIT_PRINT_ERROR_PRINTER_NOT_FOUND,
            PrintError::InvalidPageRange => ffi::WEBKIT_PRINT_ERROR_INVALID_PAGE_RANGE,
            PrintError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitPrintError> for PrintError {
    unsafe fn from_glib(value: ffi::WebKitPrintError) -> Self {
        skip_assert_initialized!();
        match value {
            599 => PrintError::General,
            500 => PrintError::PrinterNotFound,
            501 => PrintError::InvalidPageRange,
            value => PrintError::__Unknown(value),
        }
    }
}

impl ErrorDomain for PrintError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
            once_cell::sync::Lazy::new(|| unsafe {
                glib::ffi::g_quark_from_static_string(b"WebKitPrintError\0".as_ptr() as *const _)
            });
        unsafe { from_glib(*QUARK) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            599 => Some(PrintError::General),
            500 => Some(PrintError::PrinterNotFound),
            501 => Some(PrintError::InvalidPageRange),
            value => Some(PrintError::__Unknown(value)),
        }
    }
}

impl StaticType for PrintError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_print_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitPrintOperationResponse")]
pub enum PrintOperationResponse {
    #[doc(alias = "WEBKIT_PRINT_OPERATION_RESPONSE_PRINT")]
    Print,
    #[doc(alias = "WEBKIT_PRINT_OPERATION_RESPONSE_CANCEL")]
    Cancel,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PrintOperationResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PrintOperationResponse::{}",
            match *self {
                PrintOperationResponse::Print => "Print",
                PrintOperationResponse::Cancel => "Cancel",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PrintOperationResponse {
    type GlibType = ffi::WebKitPrintOperationResponse;

    fn to_glib(&self) -> ffi::WebKitPrintOperationResponse {
        match *self {
            PrintOperationResponse::Print => ffi::WEBKIT_PRINT_OPERATION_RESPONSE_PRINT,
            PrintOperationResponse::Cancel => ffi::WEBKIT_PRINT_OPERATION_RESPONSE_CANCEL,
            PrintOperationResponse::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitPrintOperationResponse> for PrintOperationResponse {
    unsafe fn from_glib(value: ffi::WebKitPrintOperationResponse) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PrintOperationResponse::Print,
            1 => PrintOperationResponse::Cancel,
            value => PrintOperationResponse::__Unknown(value),
        }
    }
}

impl StaticType for PrintOperationResponse {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_print_operation_response_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintOperationResponse {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintOperationResponse {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintOperationResponse {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_4")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitProcessModel")]
pub enum ProcessModel {
    #[doc(alias = "WEBKIT_PROCESS_MODEL_SHARED_SECONDARY_PROCESS")]
    SharedSecondaryProcess,
    #[doc(alias = "WEBKIT_PROCESS_MODEL_MULTIPLE_SECONDARY_PROCESSES")]
    MultipleSecondaryProcesses,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_4")))]
impl fmt::Display for ProcessModel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ProcessModel::{}",
            match *self {
                ProcessModel::SharedSecondaryProcess => "SharedSecondaryProcess",
                ProcessModel::MultipleSecondaryProcesses => "MultipleSecondaryProcesses",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_4")))]
#[doc(hidden)]
impl ToGlib for ProcessModel {
    type GlibType = ffi::WebKitProcessModel;

    fn to_glib(&self) -> ffi::WebKitProcessModel {
        match *self {
            ProcessModel::SharedSecondaryProcess => {
                ffi::WEBKIT_PROCESS_MODEL_SHARED_SECONDARY_PROCESS
            }
            ProcessModel::MultipleSecondaryProcesses => {
                ffi::WEBKIT_PROCESS_MODEL_MULTIPLE_SECONDARY_PROCESSES
            }
            ProcessModel::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_4")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitProcessModel> for ProcessModel {
    unsafe fn from_glib(value: ffi::WebKitProcessModel) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ProcessModel::SharedSecondaryProcess,
            1 => ProcessModel::MultipleSecondaryProcesses,
            value => ProcessModel::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_4")))]
impl StaticType for ProcessModel {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_process_model_get_type()) }
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_4")))]
impl<'a> FromValueOptional<'a> for ProcessModel {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_4")))]
impl<'a> FromValue<'a> for ProcessModel {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_4")))]
impl SetValue for ProcessModel {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitSaveMode")]
pub enum SaveMode {
    #[doc(alias = "WEBKIT_SAVE_MODE_MHTML")]
    Mhtml,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SaveMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SaveMode::{}",
            match *self {
                SaveMode::Mhtml => "Mhtml",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SaveMode {
    type GlibType = ffi::WebKitSaveMode;

    fn to_glib(&self) -> ffi::WebKitSaveMode {
        match *self {
            SaveMode::Mhtml => ffi::WEBKIT_SAVE_MODE_MHTML,
            SaveMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitSaveMode> for SaveMode {
    unsafe fn from_glib(value: ffi::WebKitSaveMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SaveMode::Mhtml,
            value => SaveMode::__Unknown(value),
        }
    }
}

impl StaticType for SaveMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_save_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SaveMode {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SaveMode {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SaveMode {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitScriptDialogType")]
pub enum ScriptDialogType {
    #[doc(alias = "WEBKIT_SCRIPT_DIALOG_ALERT")]
    Alert,
    #[doc(alias = "WEBKIT_SCRIPT_DIALOG_CONFIRM")]
    Confirm,
    #[doc(alias = "WEBKIT_SCRIPT_DIALOG_PROMPT")]
    Prompt,
    #[doc(alias = "WEBKIT_SCRIPT_DIALOG_BEFORE_UNLOAD_CONFIRM")]
    BeforeUnloadConfirm,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ScriptDialogType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ScriptDialogType::{}",
            match *self {
                ScriptDialogType::Alert => "Alert",
                ScriptDialogType::Confirm => "Confirm",
                ScriptDialogType::Prompt => "Prompt",
                ScriptDialogType::BeforeUnloadConfirm => "BeforeUnloadConfirm",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ScriptDialogType {
    type GlibType = ffi::WebKitScriptDialogType;

    fn to_glib(&self) -> ffi::WebKitScriptDialogType {
        match *self {
            ScriptDialogType::Alert => ffi::WEBKIT_SCRIPT_DIALOG_ALERT,
            ScriptDialogType::Confirm => ffi::WEBKIT_SCRIPT_DIALOG_CONFIRM,
            ScriptDialogType::Prompt => ffi::WEBKIT_SCRIPT_DIALOG_PROMPT,
            ScriptDialogType::BeforeUnloadConfirm => {
                ffi::WEBKIT_SCRIPT_DIALOG_BEFORE_UNLOAD_CONFIRM
            }
            ScriptDialogType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitScriptDialogType> for ScriptDialogType {
    unsafe fn from_glib(value: ffi::WebKitScriptDialogType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ScriptDialogType::Alert,
            1 => ScriptDialogType::Confirm,
            2 => ScriptDialogType::Prompt,
            3 => ScriptDialogType::BeforeUnloadConfirm,
            value => ScriptDialogType::__Unknown(value),
        }
    }
}

impl StaticType for ScriptDialogType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_script_dialog_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ScriptDialogType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ScriptDialogType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ScriptDialogType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitSnapshotError")]
pub enum SnapshotError {
    #[doc(alias = "WEBKIT_SNAPSHOT_ERROR_FAILED_TO_CREATE")]
    Create,
    #[doc(hidden)]
    __Unknown(i32),
}

impl SnapshotError {
    #[doc(alias = "webkit_snapshot_error_quark")]
    pub fn quark() -> glib::Quark {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::webkit_snapshot_error_quark()) }
    }
}

impl fmt::Display for SnapshotError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SnapshotError::{}",
            match *self {
                SnapshotError::Create => "Create",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SnapshotError {
    type GlibType = ffi::WebKitSnapshotError;

    fn to_glib(&self) -> ffi::WebKitSnapshotError {
        match *self {
            SnapshotError::Create => ffi::WEBKIT_SNAPSHOT_ERROR_FAILED_TO_CREATE,
            SnapshotError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitSnapshotError> for SnapshotError {
    unsafe fn from_glib(value: ffi::WebKitSnapshotError) -> Self {
        skip_assert_initialized!();
        match value {
            799 => SnapshotError::Create,
            value => SnapshotError::__Unknown(value),
        }
    }
}

impl ErrorDomain for SnapshotError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
            once_cell::sync::Lazy::new(|| unsafe {
                glib::ffi::g_quark_from_static_string(b"WebKitSnapshotError\0".as_ptr() as *const _)
            });
        unsafe { from_glib(*QUARK) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            799 => Some(SnapshotError::Create),
            value => Some(SnapshotError::__Unknown(value)),
        }
    }
}

impl StaticType for SnapshotError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_snapshot_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SnapshotError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SnapshotError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SnapshotError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitSnapshotRegion")]
pub enum SnapshotRegion {
    #[doc(alias = "WEBKIT_SNAPSHOT_REGION_VISIBLE")]
    Visible,
    #[doc(alias = "WEBKIT_SNAPSHOT_REGION_FULL_DOCUMENT")]
    FullDocument,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SnapshotRegion {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SnapshotRegion::{}",
            match *self {
                SnapshotRegion::Visible => "Visible",
                SnapshotRegion::FullDocument => "FullDocument",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SnapshotRegion {
    type GlibType = ffi::WebKitSnapshotRegion;

    fn to_glib(&self) -> ffi::WebKitSnapshotRegion {
        match *self {
            SnapshotRegion::Visible => ffi::WEBKIT_SNAPSHOT_REGION_VISIBLE,
            SnapshotRegion::FullDocument => ffi::WEBKIT_SNAPSHOT_REGION_FULL_DOCUMENT,
            SnapshotRegion::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitSnapshotRegion> for SnapshotRegion {
    unsafe fn from_glib(value: ffi::WebKitSnapshotRegion) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SnapshotRegion::Visible,
            1 => SnapshotRegion::FullDocument,
            value => SnapshotRegion::__Unknown(value),
        }
    }
}

impl StaticType for SnapshotRegion {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_snapshot_region_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SnapshotRegion {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SnapshotRegion {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SnapshotRegion {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitTLSErrorsPolicy")]
pub enum TLSErrorsPolicy {
    #[doc(alias = "WEBKIT_TLS_ERRORS_POLICY_IGNORE")]
    Ignore,
    #[doc(alias = "WEBKIT_TLS_ERRORS_POLICY_FAIL")]
    Fail,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TLSErrorsPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TLSErrorsPolicy::{}",
            match *self {
                TLSErrorsPolicy::Ignore => "Ignore",
                TLSErrorsPolicy::Fail => "Fail",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TLSErrorsPolicy {
    type GlibType = ffi::WebKitTLSErrorsPolicy;

    fn to_glib(&self) -> ffi::WebKitTLSErrorsPolicy {
        match *self {
            TLSErrorsPolicy::Ignore => ffi::WEBKIT_TLS_ERRORS_POLICY_IGNORE,
            TLSErrorsPolicy::Fail => ffi::WEBKIT_TLS_ERRORS_POLICY_FAIL,
            TLSErrorsPolicy::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitTLSErrorsPolicy> for TLSErrorsPolicy {
    unsafe fn from_glib(value: ffi::WebKitTLSErrorsPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TLSErrorsPolicy::Ignore,
            1 => TLSErrorsPolicy::Fail,
            value => TLSErrorsPolicy::__Unknown(value),
        }
    }
}

impl StaticType for TLSErrorsPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_tls_errors_policy_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TLSErrorsPolicy {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TLSErrorsPolicy {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TLSErrorsPolicy {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_24")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitUserContentFilterError")]
pub enum UserContentFilterError {
    #[doc(alias = "WEBKIT_USER_CONTENT_FILTER_ERROR_INVALID_SOURCE")]
    InvalidSource,
    #[doc(alias = "WEBKIT_USER_CONTENT_FILTER_ERROR_NOT_FOUND")]
    NotFound,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_24")))]
impl UserContentFilterError {
    #[doc(alias = "webkit_user_content_filter_error_quark")]
    pub fn quark() -> glib::Quark {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::webkit_user_content_filter_error_quark()) }
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_24")))]
impl fmt::Display for UserContentFilterError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "UserContentFilterError::{}",
            match *self {
                UserContentFilterError::InvalidSource => "InvalidSource",
                UserContentFilterError::NotFound => "NotFound",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_24")))]
#[doc(hidden)]
impl ToGlib for UserContentFilterError {
    type GlibType = ffi::WebKitUserContentFilterError;

    fn to_glib(&self) -> ffi::WebKitUserContentFilterError {
        match *self {
            UserContentFilterError::InvalidSource => {
                ffi::WEBKIT_USER_CONTENT_FILTER_ERROR_INVALID_SOURCE
            }
            UserContentFilterError::NotFound => ffi::WEBKIT_USER_CONTENT_FILTER_ERROR_NOT_FOUND,
            UserContentFilterError::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_24")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitUserContentFilterError> for UserContentFilterError {
    unsafe fn from_glib(value: ffi::WebKitUserContentFilterError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => UserContentFilterError::InvalidSource,
            1 => UserContentFilterError::NotFound,
            value => UserContentFilterError::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_24")))]
impl ErrorDomain for UserContentFilterError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
            once_cell::sync::Lazy::new(|| unsafe {
                glib::ffi::g_quark_from_static_string(
                    b"WebKitUserContentFilterError\0".as_ptr() as *const _
                )
            });
        unsafe { from_glib(*QUARK) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(UserContentFilterError::InvalidSource),
            1 => Some(UserContentFilterError::NotFound),
            value => Some(UserContentFilterError::__Unknown(value)),
        }
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_24")))]
impl StaticType for UserContentFilterError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_user_content_filter_error_get_type()) }
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_24")))]
impl<'a> FromValueOptional<'a> for UserContentFilterError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_24")))]
impl<'a> FromValue<'a> for UserContentFilterError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_24")))]
impl SetValue for UserContentFilterError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitUserContentInjectedFrames")]
pub enum UserContentInjectedFrames {
    #[doc(alias = "WEBKIT_USER_CONTENT_INJECT_ALL_FRAMES")]
    AllFrames,
    #[doc(alias = "WEBKIT_USER_CONTENT_INJECT_TOP_FRAME")]
    TopFrame,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl fmt::Display for UserContentInjectedFrames {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "UserContentInjectedFrames::{}",
            match *self {
                UserContentInjectedFrames::AllFrames => "AllFrames",
                UserContentInjectedFrames::TopFrame => "TopFrame",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
#[doc(hidden)]
impl ToGlib for UserContentInjectedFrames {
    type GlibType = ffi::WebKitUserContentInjectedFrames;

    fn to_glib(&self) -> ffi::WebKitUserContentInjectedFrames {
        match *self {
            UserContentInjectedFrames::AllFrames => ffi::WEBKIT_USER_CONTENT_INJECT_ALL_FRAMES,
            UserContentInjectedFrames::TopFrame => ffi::WEBKIT_USER_CONTENT_INJECT_TOP_FRAME,
            UserContentInjectedFrames::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitUserContentInjectedFrames> for UserContentInjectedFrames {
    unsafe fn from_glib(value: ffi::WebKitUserContentInjectedFrames) -> Self {
        skip_assert_initialized!();
        match value {
            0 => UserContentInjectedFrames::AllFrames,
            1 => UserContentInjectedFrames::TopFrame,
            value => UserContentInjectedFrames::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl StaticType for UserContentInjectedFrames {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_user_content_injected_frames_get_type()) }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl<'a> FromValueOptional<'a> for UserContentInjectedFrames {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl<'a> FromValue<'a> for UserContentInjectedFrames {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl SetValue for UserContentInjectedFrames {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitUserMessageError")]
pub enum UserMessageError {
    #[doc(alias = "WEBKIT_USER_MESSAGE_UNHANDLED_MESSAGE")]
    Message,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl UserMessageError {
    #[doc(alias = "webkit_user_message_error_quark")]
    pub fn quark() -> glib::Quark {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::webkit_user_message_error_quark()) }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl fmt::Display for UserMessageError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "UserMessageError::{}",
            match *self {
                UserMessageError::Message => "Message",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
#[doc(hidden)]
impl ToGlib for UserMessageError {
    type GlibType = ffi::WebKitUserMessageError;

    fn to_glib(&self) -> ffi::WebKitUserMessageError {
        match *self {
            UserMessageError::Message => ffi::WEBKIT_USER_MESSAGE_UNHANDLED_MESSAGE,
            UserMessageError::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitUserMessageError> for UserMessageError {
    unsafe fn from_glib(value: ffi::WebKitUserMessageError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => UserMessageError::Message,
            value => UserMessageError::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl ErrorDomain for UserMessageError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
            once_cell::sync::Lazy::new(|| unsafe {
                glib::ffi::g_quark_from_static_string(
                    b"WebKitUserMessageError\0".as_ptr() as *const _
                )
            });
        unsafe { from_glib(*QUARK) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(UserMessageError::Message),
            value => Some(UserMessageError::__Unknown(value)),
        }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl StaticType for UserMessageError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_user_message_error_get_type()) }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl<'a> FromValueOptional<'a> for UserMessageError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl<'a> FromValue<'a> for UserMessageError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl SetValue for UserMessageError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitUserScriptInjectionTime")]
pub enum UserScriptInjectionTime {
    #[doc(alias = "WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_START")]
    Start,
    #[doc(alias = "WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_END")]
    End,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl fmt::Display for UserScriptInjectionTime {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "UserScriptInjectionTime::{}",
            match *self {
                UserScriptInjectionTime::Start => "Start",
                UserScriptInjectionTime::End => "End",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
#[doc(hidden)]
impl ToGlib for UserScriptInjectionTime {
    type GlibType = ffi::WebKitUserScriptInjectionTime;

    fn to_glib(&self) -> ffi::WebKitUserScriptInjectionTime {
        match *self {
            UserScriptInjectionTime::Start => ffi::WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_START,
            UserScriptInjectionTime::End => ffi::WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_END,
            UserScriptInjectionTime::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitUserScriptInjectionTime> for UserScriptInjectionTime {
    unsafe fn from_glib(value: ffi::WebKitUserScriptInjectionTime) -> Self {
        skip_assert_initialized!();
        match value {
            0 => UserScriptInjectionTime::Start,
            1 => UserScriptInjectionTime::End,
            value => UserScriptInjectionTime::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl StaticType for UserScriptInjectionTime {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_user_script_injection_time_get_type()) }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl<'a> FromValueOptional<'a> for UserScriptInjectionTime {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl<'a> FromValue<'a> for UserScriptInjectionTime {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl SetValue for UserScriptInjectionTime {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitUserStyleLevel")]
pub enum UserStyleLevel {
    #[doc(alias = "WEBKIT_USER_STYLE_LEVEL_USER")]
    User,
    #[doc(alias = "WEBKIT_USER_STYLE_LEVEL_AUTHOR")]
    Author,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl fmt::Display for UserStyleLevel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "UserStyleLevel::{}",
            match *self {
                UserStyleLevel::User => "User",
                UserStyleLevel::Author => "Author",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
#[doc(hidden)]
impl ToGlib for UserStyleLevel {
    type GlibType = ffi::WebKitUserStyleLevel;

    fn to_glib(&self) -> ffi::WebKitUserStyleLevel {
        match *self {
            UserStyleLevel::User => ffi::WEBKIT_USER_STYLE_LEVEL_USER,
            UserStyleLevel::Author => ffi::WEBKIT_USER_STYLE_LEVEL_AUTHOR,
            UserStyleLevel::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitUserStyleLevel> for UserStyleLevel {
    unsafe fn from_glib(value: ffi::WebKitUserStyleLevel) -> Self {
        skip_assert_initialized!();
        match value {
            0 => UserStyleLevel::User,
            1 => UserStyleLevel::Author,
            value => UserStyleLevel::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl StaticType for UserStyleLevel {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_user_style_level_get_type()) }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl<'a> FromValueOptional<'a> for UserStyleLevel {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl<'a> FromValue<'a> for UserStyleLevel {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl SetValue for UserStyleLevel {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitWebProcessTerminationReason")]
pub enum WebProcessTerminationReason {
    #[doc(alias = "WEBKIT_WEB_PROCESS_CRASHED")]
    Crashed,
    #[doc(alias = "WEBKIT_WEB_PROCESS_EXCEEDED_MEMORY_LIMIT")]
    ExceededMemoryLimit,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
impl fmt::Display for WebProcessTerminationReason {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "WebProcessTerminationReason::{}",
            match *self {
                WebProcessTerminationReason::Crashed => "Crashed",
                WebProcessTerminationReason::ExceededMemoryLimit => "ExceededMemoryLimit",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
#[doc(hidden)]
impl ToGlib for WebProcessTerminationReason {
    type GlibType = ffi::WebKitWebProcessTerminationReason;

    fn to_glib(&self) -> ffi::WebKitWebProcessTerminationReason {
        match *self {
            WebProcessTerminationReason::Crashed => ffi::WEBKIT_WEB_PROCESS_CRASHED,
            WebProcessTerminationReason::ExceededMemoryLimit => {
                ffi::WEBKIT_WEB_PROCESS_EXCEEDED_MEMORY_LIMIT
            }
            WebProcessTerminationReason::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitWebProcessTerminationReason> for WebProcessTerminationReason {
    unsafe fn from_glib(value: ffi::WebKitWebProcessTerminationReason) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WebProcessTerminationReason::Crashed,
            1 => WebProcessTerminationReason::ExceededMemoryLimit,
            value => WebProcessTerminationReason::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
impl StaticType for WebProcessTerminationReason {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_web_process_termination_reason_get_type()) }
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
impl<'a> FromValueOptional<'a> for WebProcessTerminationReason {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
impl<'a> FromValue<'a> for WebProcessTerminationReason {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
impl SetValue for WebProcessTerminationReason {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}
